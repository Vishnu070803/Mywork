Look the USB OTG chapter, explain me how host asking for data from certain address and how device providing that data
Explain the data flow in the USB communication
How does data transfer happens between driver and device, who defines the data address which particular data driver want or want to write
The Universal Serial Bus (USB) protocol facilitates communication between a host computer and peripheral devices, with the host always initiating transactions
. This design supports a "plug-and-play" system where devices are automatically configured by the host
.
Here's an explanation of USB communication, focusing on data transfer, host requests, and how data addresses are managed between a driver and a device:
USB Communication Data Flow
USB 2.0 communication is half-duplex, meaning data transmission and reception cannot occur simultaneously
. It operates based on a polling mechanism, where only the host can initiate a transaction on the bus; connected devices can only respond to these requests
.
USB communication is structured into a series of frames
. Each frame begins with a Start of Frame (SOF) packet. Within each frame, one or more transactions take place. A transaction is composed of three main components: a token packet, an optional data packet, and a handshake packet
.
There are four primary types of packets in the USB 2.0 specification
:
•
Token packets: Always initiated by the host, these packets direct traffic and determine the type of transaction
. Examples include:
◦
IN token packet: Used by the host to request data from the device
.
◦
OUT token packet: Notifies the device that the host is ready to send data
.
◦
SETUP token packet: Issued during device setup and configuration
.
◦
SOF token packet: Marks the beginning of a new frame and includes a frame number
.
•
Data packets: These carry the actual payload data
. They include a Packet ID (PID) (DATA0 or DATA1) which toggles between successive packets to help detect packet loss, optional device and endpoint addresses, and a Cyclic Redundancy Check (CRC) for error detection. The payload size can range from 0 to 1024 bytes
.
•
Handshake packets: Sent by the receiver to conclude a transaction
. Common types include ACK (successful completion), NAK (negative acknowledgment), STALL (error indication), and NYET (device not ready to receive, supported only on High-Speed devices)
.
•
Special packets: These include PRE (preamble for low-speed packets) and PING (used by High-Speed devices to check status)
.
USB Endpoints and Pipes
To manage data flow, USB architecture uses endpoints and pipes
.
•
An endpoint is a uniquely addressable buffer on a USB device, functioning as a hardware component independent of the host operating system
. Endpoints are unidirectional, meaning data can only flow in one direction (either IN from the device to the host, or OUT from the host to the device)
.
◦
All USB devices must support a Control Endpoint (Endpoint 0), which is bidirectional and used for initial communication, device discovery, and configuration
.
◦
Data endpoints are optional and typically fall into one of four types: Control, Interrupt, Bulk, or Isochronous
.
•
A pipe is a software abstraction on the host side, representing a communication channel established between a specific endpoint on the USB device and the host controller
. A pipe is "opened" when the device is configured by selecting a configuration and an interface's alternate setting, making it active for I/O operations. Therefore, an unconfigured endpoint is called an endpoint, while a configured endpoint is called a pipe
.
Host Requesting Data from a Device
In USB OTG, once the controller is in Host mode, it operates with full host functionality
. The host initiates data requests using IN token packets. These packets contain a 7-bit device address and a 4-bit endpoint address to specify the target location on the device
.
When the host requests data (an upstream transaction or IN transaction), the sequence is as follows
:
1.
The host sends an IN token packet to the specified device and endpoint
.
2.
The device, if ready, sends one or more data packets (DATA0/DATA1) containing the requested information to the host
.
3.
The host then responds with a handshake packet (e.g., ACK for successful reception)
.
4.
If the device is not ready to send data, it can respond with a NAK (Negative Acknowledgment), indicating that the host should retry later
.
For initial device configuration, the host uses Control Transfers directed to Endpoint 0. For instance, the host sends a GET_DESCRIPTOR command to obtain the device descriptor, which provides essential information like the maximum packet size for Endpoint 0
.
Device Providing Data
A USB device prepares to provide data by organizing its internal structure with device endpoints
. In Device mode, the device controller uses device Queue Heads (dQH) and device Transfer Descriptors (dTD) to manage data transfers
.
•
The dQH defines the type of data transfer and points to the first dTD in a linked list
.
•
The dTD includes a system address pointer to the memory buffer from which data is read or written
.
When the device controller is "primed" for a transmit (IN) endpoint, it fetches the relevant dTD into its dQH, allowing for a swift response to an IN request from the host, crucial for meeting High-Speed USB turnaround times
. After a dTD transfer is completed, the controller writes the dTD back to system memory, updating its status and indicating transfer results
.
Data Transfer Between Driver and Device: Defining Data Addresses
On host systems like Linux, the USB Request Block (URB) is the primary mechanism for the kernel to communicate with USB devices
. An URB is used to send or receive data asynchronously to or from a specific USB endpoint on a specific USB device
.
The process involves:
1.
URB Creation and Assignment: A USB device driver creates an URB (e.g., using usb_alloc_urb in Linux) and assigns it to a specific endpoint of a specific USB device
. Functions like usb_rcvintpipe or usb_sndbulkpipe are used to define the direction and type of the pipe (endpoint) for the URB
.
2.
Data Buffer Allocation: The USB client driver (HCD/DCD software) defines the data address by allocating a memory buffer (e.g., using kmalloc in Linux)
.
3.
Buffer Assignment to URB: The driver then sets the transfer_buffer field within the URB structure to point to this allocated data buffer
. For control URBs, a setup_packet buffer can also be specified
.
4.
URB Submission: The driver submits the initialized URB to the USB core (usb_submit_urb), which then forwards it to the host controller driver for processing
.
5.
Completion and Status: Once the URB is processed by the USB host controller, a completion handler function defined by the driver is called. This handler receives the URB, allowing the driver to inspect the actual_length of data transferred (for IN transfers) and the status of the operation
.
For simpler data transfers, functions like usb_bulk_msg and usb_control_msg exist, which encapsulate the URB creation and submission process. These functions take a void *data parameter, which serves as the buffer for sending or receiving data, and the int *actual_length parameter to report the amount of data transferred
. These simplified functions also operate on buffers whose addresses are defined by the calling driver
.
In summary, the host's driver (HCD) dictates what data it wants or wants to write by setting up URBs with specific endpoint pipes and providing the memory addresses of the data buffers. The device's firmware and device controller driver (DCD) then handle the data flow to/from its internal buffers as guided by its descriptors, which include pointers to the relevant data in system memory.

the question i am unable to understand the where does the USb device driver asking data from particular address from the device, USB device driver only asking from the particular endpoint, how can these even possible
The core of your query lies in understanding the distinction between addressing a specific logical component on a USB device (an endpoint) and addressing a specific memory location within that device. In USB communication, the host interacts with logical endpoints, not direct memory addresses within the device's internal storage
.
Here's how this process unfolds:
How Host Asks for Data (Endpoints are the "Addresses")
The USB protocol is inherently host-centric, meaning only the host can initiate communication or transactions on the bus
. This is achieved through a polling mechanism
.
When a host wants to obtain data from a USB device, it doesn't request data from a specific memory address inside the device's flash, RAM, or registers. Instead, it requests data from a specific endpoint on that device
.
•
An endpoint is defined as a uniquely addressable buffer on the USB device itself
. It's a hardware component that serves as a source or sink for data
.
•
Endpoints are unidirectional; data can only flow in one direction: either IN (from the device to the host) or OUT (from the host to the device)
.
•
To request data, the host sends an IN token packet
. This token packet is crucial because it contains:
◦
A 7-bit device address, which identifies the specific USB device on the bus
.
◦
A 4-bit endpoint address, which specifies which particular endpoint on that device the host wishes to communicate with
.
•
So, from the perspective of the USB bus and the host, the "particular address" for data is the combination of the device address and the endpoint address in the token packet. This directs the request to a specific logical channel on the device
.
For initial communication and configuration, all USB devices must support a Control Endpoint (Endpoint 0)
. This endpoint is bidirectional
. The host uses Control Transfers to Endpoint 0 during the enumeration process to:
•
Identify the device: The host sends a GET_DESCRIPTOR command to request the device descriptor
. This descriptor contains essential information about the device, such as its idVendor, idProduct, and the bMaxPacketSize0 (maximum packet size for Endpoint 0)
.
•
Learn about device capabilities: Other descriptors (configuration, interface, endpoint, string) are then read to understand the device's functions, its interfaces, and the capabilities of its other data endpoints
.
•
Assign an address and configure: After reading descriptors, the host assigns a unique address to the device (SET_ADDRESS command) and selects a configuration (SET_CONFIGURATION command)
.
This process allows the host to understand what data the device offers (e.g., mass storage data, keyboard input, audio stream) and through which endpoint (e.g., Bulk IN endpoint for mass storage reads, Interrupt IN endpoint for keyboard input)
. The host doesn't send a request like "give me the data at memory address 0x12345678 inside your internal flash." Instead, it says, "Device X, Endpoint Y, give me your data."
How Device Provides That Data
On the device side, its internal firmware and hardware are designed to map these logical endpoints to actual internal data buffers or functions.
•
USB devices manage data transfers using structures like device Queue Heads (dQH) and device Transfer Descriptors (dTD)
.
•
A dQH defines the type of data transfer (e.g., IN or OUT) and points to a linked list of dTDs
.
•
Crucially, a dTD includes a system address pointer to the memory buffer(s) where the data is either stored (for IN transfers, data to be sent to the host) or where received data should be written (for OUT transfers, data from the host)
.
•
When the host sends an IN token packet to a primed transmit endpoint, the device controller can quickly fetch the necessary dTD from its dQH (which holds a copy in its overlay area) and begin sending the data from the device's internal buffers to the host, meeting the stringent turnaround times for High-Speed USB
.
•
After the data transfer described by a dTD is completed, the device controller writes the dTD back to system memory, updating its status and indicating the transfer results
.
Data Transfer Between Driver and Device: Who Defines the Data Address
On the host system (e.g., a Linux computer), the USB driver is responsible for defining the memory addresses for data transfer. This is typically managed through USB Request Blocks (URBs)
.
1.
URB Creation and Assignment: A USB device driver first allocates a URB (e.g., using usb_alloc_urb in Linux)
. The driver then assigns this URB to a specific endpoint (referred to as a "pipe" in the host's software abstraction) on a particular USB device. Functions like usb_sndbulkpipe (send data over bulk OUT endpoint) or usb_rcvintpipe (receive data over interrupt IN endpoint) are used to specify the pipe's direction and type
.
2.
Host Data Buffer Allocation: The USB driver defines the data address by allocating a memory buffer in the host's system memory (e.g., using kmalloc or usb_buffer_alloc in Linux)
. This is the buffer where data will be read into (for IN transfers) or written from (for OUT transfers) by the host controller.
3.
Buffer Assignment to URB: The address of this host-side buffer is then set in the URB's transfer_buffer field (or transfer_dma for DMA transfers)
. For control transfers, a separate setup_packet buffer can also be specified
.
4.
URB Submission: The driver submits the configured URB to the USB core (usb_submit_urb)
. The USB core then passes it to the appropriate host controller driver (HCD)
.
5.
Hardware Transfer: The HCD, interacting with the USB host controller hardware, manages the actual physical data transfer between the host's memory buffer (whose address was supplied in the URB) and the device's specified endpoint
.
6.
Completion: Once the transfer is complete (or an error occurs), the host controller notifies the HCD, which in turn calls a completion handler function defined by the driver
. The driver can then check the actual_length of data transferred and the status of the operation within the URB
.
For simplified synchronous transfers, helper functions like usb_bulk_msg or usb_control_msg can be used. These functions internally handle URB creation and submission, taking a void *data parameter for the data buffer, whose address is provided by the calling driver
.
In summary, the USB device driver doesn't ask for data from a "particular address" in the device's internal memory in the way a CPU might access RAM. Instead, it requests data from a logical endpoint on the device, which acts as an abstraction for data flow. The device's firmware and hardware are responsible for mapping these endpoint requests to their actual internal memory buffers. On the host side, the driver defines the data address by allocating a buffer in the host's system memory and specifying its address in the URB, which then facilitates the transfer via the USB host controller.

1 tell me from user space to device, how data writes happens and similarly how data read happens, explain for general
2 For example two devices were there like two zybo boards one is acting as host another as device, host side user application want to read certain data from the device system memory ( a file may be) and similarly want to write certain particular data from host system memory to device particular address of the system memory
To understand how a USB device driver reads and writes data, including concepts like "system memory" and "files" when communicating with a device, it's essential to grasp the layered nature of USB communication and the roles of both the host and the device.
1. General Data Flow: User-space to Device and Vice Versa
The USB protocol is host-centric, meaning that only the host can initiate communication or transactions on the bus through a polling mechanism
. A USB device contains a collection of endpoints, which are uniquely addressable portions of the device that share information with the host. Endpoints are unidirectional; data can only flow from the device to the host (IN) or from the host to the device (OUT)
.
On the host side, a communication channel called a pipe is established between a specific endpoint on the USB device and the host controller. The pipe is a software abstraction on the host side, whereas the endpoint is hardware on the device
.
Data Write (User-space to Device)
When a user-space application wants to send data to a USB device, the process typically involves these steps:
1.
User-space Application to USB Driver: The user-space application (e.g., a program saving data to a USB stick) makes a system call to the operating system's kernel, providing the data to be written and specifying the target device.
2.
USB Driver Prepares Data: The USB device driver in the kernel receives this request. It allocates a memory buffer in the host's system memory where the data from the user application will be temporarily stored
. This buffer must be created using appropriate kernel memory allocation functions (e.g., kmalloc in Linux)
.
3.
USB Request Block (URB) Creation: The driver then creates and configures a USB Request Block (URB)
. The URB is the fundamental structure for communicating with USB devices in the Linux kernel
. For a write operation, the driver:
◦
Points the URB's transfer_buffer field to the allocated host-side memory buffer containing the data to be sent
.
◦
Specifies the length of the data to be transferred in transfer_buffer_length
.
◦
Assigns the URB to a specific OUT endpoint on the USB device using a "pipe" function (e.g., usb_sndbulkpipe for bulk transfers or usb_sndctrlpipe for control transfers)
.
◦
Sets a completion handler function (usb_complete_t) that the USB core will call once the transfer is finished
.
4.
URB Submission: The driver submits the fully configured URB to the USB core (usb_submit_urb)
.
5.
USB Core and Host Controller: The USB core passes the URB to the appropriate Host Controller Driver (HCD). The HCD interacts with the USB host controller hardware to manage the physical data transfer. The host controller fetches data from the host's memory buffer (specified in the URB) and sends it over the USB bus as data packets to the device's specified endpoint
. The host initiates this by sending an OUT token packet, which contains the device address and endpoint address, followed by the data packets
.
6.
Device Reception: On the device side, its USB controller receives the data packets targeted at the specified OUT endpoint. The device's internal firmware uses structures like device Queue Heads (dQH) and device Transfer Descriptors (dTD) to manage incoming data
. The dTD includes a system address pointer to the memory buffer(s) within the device where the received data should be written. The device's DMA engine moves data from its Rx FIFOs to its system memory
.
7.
Completion Notification: Once the data is successfully received by the device and written to its internal buffers, the device sends a handshake packet (e.g., ACK) back to the host
. The host controller then notifies the host USB driver via the URB's completion handler. The driver can then free the host-side buffer or reuse the URB
.
Data Read (Device to User-space)
When a user-space application wants to read data from a USB device, the flow is largely reversed:
1.
User-space Application to USB Driver: The user-space application requests data from the kernel, specifying the device and desired amount of data.
2.
USB Driver Prepares Buffer: The USB driver allocates a memory buffer in the host's system memory to receive the incoming data
.
3.
URB Creation: The driver creates and configures a URB. For a read operation:
◦
It specifies the host-side buffer for receiving data (transfer_buffer) and its maximum length (transfer_buffer_length)
.
◦
It assigns the URB to a specific IN endpoint on the USB device using a pipe function (e.g., usb_rcvbulkpipe for bulk transfers or usb_rcvintpipe for interrupt transfers)
.
◦
It sets a completion handler (usb_complete_t)
.
4.
URB Submission: The driver submits the URB to the USB core
.
5.
Host Initiates Transfer: The USB core and HCD interact with the host controller. The host controller sends an IN token packet on the USB bus
. This token contains the device address and the endpoint address from which the host expects to receive data
.
6.
Device Responds: The device's USB controller receives the IN token. If the specified endpoint is primed (meaning the device's internal firmware has prepared data to be sent, or is ready to generate it)
, the device controller fetches data from its internal memory buffers (using dTDs which point to actual memory locations) into its Tx FIFOs. It then sends one or more data packets (e.g., DATA0/DATA1) back to the host
.
7.
Host Receives Data: The host controller receives these data packets and writes the data into the specified transfer_buffer in the host's system memory.
8.
Completion Notification: After the transfer is complete, the device sends a handshake packet (e.g., ACK)
. The host controller updates the URB's actual_length field with the number of bytes actually received and calls the URB's completion handler. The driver can then process the received data from the host-side buffer
.
2. Example: Zybo Boards (Host and Device) - File Read/Write
Your example with two Zybo boards (one host, one device) and the concept of reading/writing a "file" from/to the device's "system memory" highlights the abstraction provided by USB device classes.
Crucial Point: The USB protocol itself does not provide direct access to specific memory addresses or file systems on the device in the same way a CPU accesses its local RAM. Instead, it operates on a higher, more abstract level using endpoints and device classes.
For reading/writing a "file" or accessing "system memory" on a USB device, the most common scenario is the USB Mass Storage Device Class (USB MSC)
.
Here's how it would work:
1.
Device-side (Zybo acting as device):
◦
The Zybo board would need to run firmware that implements the USB MSC specification
. This means it presents itself to the host as a mass storage device (like a thumb drive or external hard drive)
.
◦
The MSC specification defines how the device reports its storage capabilities (e.g., total sectors) and how the host can read/write data in sectors, not specific memory addresses
. It typically uses the SCSI transparent command set to achieve this
.
◦
The device firmware would have its own internal file system (e.g., FAT32, ext4) on its actual storage (e.g., an SD card, NAND flash, or internal RAM acting as storage)
. The file system is managed by the device's operating system/firmware.
◦
The device's USB controller (e.g., the Zynq-7000 SoC's USB controller, which includes built-in DMA
) would be configured for device mode. It would have at least two Bulk Endpoints (one IN, one OUT) in addition to the mandatory Control Endpoint 0, which are used for the actual data transfer
.
2.
Host-side (Zybo acting as host):
◦
The Zybo board acting as the host would run a USB host controller driver (HCD) (e.g., EHCI compatible in Linux)
 and a USB Mass Storage (UMS) driver (e.g., usb-storage.c in Linux).
◦
The UMS driver on the host would interpret the device as a standard block device (like /dev/sdb in Linux), regardless of whether it's a flash drive, hard drive, or your custom Zybo board
.
◦
The host OS would then mount a file system on this block device, allowing user applications to interact with it using standard file operations (open, read, write, close).
Flow for File Read/Write in the Zybo Example (through MSC):
•
Host Application Requests to Read "file.txt":
1.
The user application (on Host Zybo) calls open("file.txt", O_RDONLY) and read() [Outside Source].
2.
The Host OS's file system driver (e.g., ext4, FAT) translates this file operation into a request for specific logical block addresses (LBAs) or sectors on the /dev/sdb device [Outside Source, 126].
3.
The Host's UMS driver then converts these LBA/sector requests into SCSI commands (e.g., "READ(10)" or "READ(12)")
.
4.
The USB driver (in the kernel) prepares a Control Transfer for the SCSI command (often via a Command Block Wrapper (CBW) for Bulk-Only Transport
) and then prepares a Bulk IN Transfer to receive the data.
5.
The USB driver submits these URBs to the USB core for transmission over the USB bus via the host controller to the device's Bulk OUT and Bulk IN endpoints
.
6.
On the Device (Zybo acting as device):
▪
The device's USB controller receives the CBW on its Bulk OUT endpoint, parses the SCSI "READ" command.
▪
The device's firmware translates this SCSI command to an internal operation to read the corresponding sectors from its actual storage (e.g., SD card or emulated memory)
.
▪
The device's USB controller, using its internal dQH and dTD structures, primes its Bulk IN endpoint with the requested sector data from its internal memory buffers
.
▪
When the Host sends an IN token, the device sends the data in data packets via its Bulk IN endpoint
.
7.
Back on the Host (Zybo acting as host):
▪
The Host's USB controller receives the data packets from the device's Bulk IN endpoint and writes them into the host's specified memory buffer.
▪
The UMS driver processes the received data, potentially performs error checking (e.g., CRC
), and passes it up to the file system driver.
▪
The file system driver reconstructs the file data and provides it to the user application.
•
Host Application Requests to Write to "file.txt":
1.
The user application (on Host Zybo) calls open("file.txt", O_WRONLY) and write() [Outside Source].
2.
The Host OS's file system driver translates this into a request for specific sectors on the /dev/sdb device [Outside Source, 126].
3.
The Host's UMS driver converts these into SCSI commands (e.g., "WRITE(10)" or "WRITE(12)") and associates the user's data with these commands
.
4.
The USB driver prepares a Control Transfer (CBW
) and a Bulk OUT Transfer containing the data to be written.
5.
The USB driver submits these URBs to the USB core for transmission to the device's Bulk OUT endpoint
.
6.
On the Device (Zybo acting as device):
▪
The device's USB controller receives the CBW and data packets on its Bulk OUT endpoint.
▪
Its firmware interprets the SCSI "WRITE" command, taking the data from the endpoint buffer and writing it to the specified sectors on its internal storage
.
▪
The device sends a Command Status Wrapper (CSW) via its Bulk IN endpoint, indicating success or failure
.
7.
Back on the Host (Zybo acting as host):
▪
The Host's USB controller receives the CSW.
▪
The UMS driver checks the status and reports success or failure up the stack to the user application.
The Zynq-7000 SoC (which is likely on a Zybo board) includes a USB Host, Device, and OTG Controller
. This controller has a built-in DMA engine that handles data transfers between the controller's Rx/Tx FIFOs and the system memory (DDR, OCM, or PL-mapped memory). On the device side, this DMA engine processes transfer descriptors (dQH, dTD) to move data efficiently. The dual-port RAM within the controller is used for these Rx and Tx data FIFOs and for storing context information. This hardware acceleration is crucial for meeting the real-time demands of USB, especially at high speeds
.

Mind map these communication
Based on your query, "Mind map these communication", and drawing from the provided sources, here is a comprehensive mind map focusing on the communication protocols and interfaces discussed, primarily USB communication, along with other peripheral interfaces found in the Zynq-7000 SoC.
Mind Map: Communication Protocols and Interfaces
I. USB Communication
•
Fundamental Principles
◦
Polling Mechanism: USB 2.0 operates on a polling mechanism where only the host initiates transactions on the bus
.
◦
Directionality: Communication in USB 2.0 is half-duplex, meaning data transmission and reception cannot occur simultaneously
.
▪
IN Data: Information moves from the device to the host
.
▪
OUT Data: Information moves from the host to the device
.
◦
Data Transmission: Data on the USB bus is transmitted with the least significant bit (LSB) first
.
◦
Frames/Microframes:
▪
For Low-Speed (1.5 Mbit/s) and Full-Speed (12 Mbit/s) devices, the host controller divides bus time into 1 ms frames
.
▪
For High-Speed devices (480 Mbit/s), each frame is 125 µs, called microframes
.
▪
Multiple transactions can take place within each frame or microframe
.
◦
Error Detection: Cyclic Redundancy Checks (CRC) are used to detect errors in transactions, calculating a checksum appended to the data packet for integrity verification
.
•
USB Endpoints
◦
Definition: Uniquely addressable portions of a USB device that share information with the host
.
◦
Unidirectional: Data flow is permitted only in the direction allowed by the endpoint
.
◦
Types: USB specification defines 32 endpoints (16 IN and 16 OUT) accessible after initial configuration
.
◦
Control Endpoint (Endpoint 0):
▪
A special set of endpoints used for initial communication
.
▪
Defined as Endpoint 0 IN and Endpoint 0 OUT, acting as a default endpoint for host-device communication
.
▪
Bidirectional and crucial for USB system-level control and device setup/initial configuration
.
▪
Plays an important role in the device enumeration process
.
•
USB Pipes
◦
Definition: Channels established between a specific endpoint on the USB device and the host controller
.
◦
Software Abstraction: "Pipe" is a purely software term
.
◦
Lifecycle: A pipe for an endpoint is opened when the device is configured by selecting a configuration and an interface's alternate setting
. An unconfigured endpoint is simply an "endpoint", while a configured one is a "pipe"
.
◦
Host Connection: One end of the pipe is always the host controller
.
•
USB Transfer Types
◦
These transfer types are defined to cater to the diverse functionalities and polling rate requirements of connected USB devices
.
◦
Control Transfers:
▪
Mandatory: All devices must support them
.
▪
Purpose: System-level control, initial configuration, and device enumeration
.
▪
Stages: Involve a setup stage (host sends USB requests, device always acknowledges), an optional data stage (for payload transfer), and a status stage (reports success/failure with a zero-length DATA1 packet)
.
▪
Bandwidth: Have 10% reserved bandwidth for Low-Speed and Full-Speed devices, and 20% for High-Speed devices
.
◦
Interrupt Transfers:
▪
Polling: Host checks for data at predictable intervals (not a true interrupt mechanism)
.
▪
Reliability: Offer high data reliability for small amounts of data and guarantee accuracy with error detection and retransmission
.
▪
Use Cases: Essential for Human Interface Devices (HID) like keyboards, mice, and game controllers
.
▪
Bandwidth: Guaranteed to have enough reserved bandwidth
.
◦
Bulk Transfers:
▪
Purpose: Transfer large amounts of data
.
▪
Reliability: Guaranteed no data loss, but not guaranteed to make it through in a specific amount of time
.
▪
Packet Handling: Large packets may be split across multiple transfers
.
▪
Use Cases: Common for devices like printers, storage drives, and network devices
.
▪
Mass Storage Class (Bulk-Only Transport): Commands (Command Block Wrapper - CBW), data, and status (Command Status Wrapper - CSW) are all transported via Bulk endpoints
.
◦
Isochronous Transfers:
▪
Purpose: Support continuous, real-time transfers with pre-negotiated bandwidth
.
▪
Error Handling: Detect errors but are error-tolerant; they do not support error recovery mechanisms or handshaking
.
▪
Use Cases: Used for streaming applications (e.g., audio and video) where occasional data loss is acceptable
.
▪
Bandwidth: Guaranteed 90% bandwidth on Low- and Full-Speed devices, and 80% on High-Speed devices (shared with interrupt transfers)
.
▪
Availability: Not available on Low-Speed devices
.
•
USB Packet Structure and IDs
◦
Packet Indicators: New packets are indicated by a sync pattern, and the end of a packet by an End of Packet (EOP)
.
◦
Packet Identifiers (PIDs):
▪
Token PIDs: OUT, IN, SOF (Start of Frame), SETUP
.
•
IN token starts an upstream (device to host) transaction
.
•
OUT token starts a downstream (host to device) transaction
.
▪
Data PIDs: DATA0, DATA1
.
▪
Handshake PIDs: ACK (Acknowledge successful completion), NAK (Negative acknowledgement), STALL (Error indication), NYET (Not ready to receive)
. NYET is High-Speed only
.
▪
Special PIDs: PRE (Preamble for low-speed packets on Full-/High-Speed devices), PING (checks status of High-Speed devices after NYET)
.
•
USB Driver Interaction
◦
Client Driver: Creates requests by formatting a USB Request Block (URB) to transfer data
.
◦
Pipe Handles: Client drivers access pipe handles created by the USB driver stack after device configuration
.
◦
Zynq-7000 SoC USB Controller:
▪
Operates in both Host and Device modes
.
▪
Uses a DMA Engine and a Protocol Engine
.
▪
Employs Dual-Port RAM for Rx/Tx FIFOs and context information
.
▪
Manages transfers using link-list descriptors:
•
Device Mode: Device Queue Heads (dQH) and Device Transfer Descriptors (dTD)
.
•
Host Mode: Queue Heads (QH), Queue Element Transfer Descriptors (qTD), Isochronous Transfer Descriptors (iTD), Split Transaction Isochronous Transfer Descriptors (siTD), and Periodic Frame Span Traversal Nodes (FSTN)
.
▪
Includes an Embedded Transaction Translator (TT) function within the DMA and protocol engines to support direct connection to Low-Speed and Full-Speed devices without needing an external USB 2.0 hub
.
II. Other Communication Interfaces (Zynq-7000 SoC)
•
Ethernet Controller (GEM)
◦
Quantity: Two Gigabit Ethernet (GigE) controllers
.
◦
Speeds: Supports 10/100/1000 Mb/s operation
.
◦
Data Transfer: Utilizes a DMA controller connected to memory via an AHB bus
.
◦
Time Stamping: Supports IEEE 1588 version 2 PTP (Precision Time Protocol) time stamping
.
◦
Routing: I/O can be routed via MIO (RGMII) or EMIO (GMII/MII) interfaces to PL pins
.
◦
Buffer Descriptors: Uses transmit and receive buffer descriptors for managing data transfer
.
•
SPI Controller
◦
Quantity: Two independent SPI controllers
.
◦
Modes: Can function in master, slave, or multi-master modes
.
◦
Bus: Uses a four-wire bus: MOSI, MISO, SCLK, and SS (Slave Select)
.
◦
Operation: Offers full-duplex operation, allowing simultaneous receive and transmit
.
◦
Buffering: Equipped with 128-byte read (RxFIFO) and 128-byte write (TxFIFO) FIFOs
.
◦
Routing: I/O signals can be routed to either MIO pins or the EMIO interface to the PL
.
•
CAN Controller
◦
Quantity: Two nearly identical CAN controllers
.
◦
Standards: Compatible with ISO 11898-1, CAN 2.0A, and CAN 2.0B standards
.
◦
Bit Rates: Supports bit rates up to 1 Mb/s
.
◦
Buffering: Features a TxFIFO (64 messages) and an RxFIFO (64 messages), along with one high-priority transmit buffer (TxHPB)
.
◦
Filtering: Incorporates four Rx acceptance filters with enables, masks, and IDs for message filtering
.
◦
Time Stamping: Provides 16-bit time stamping for received messages
.
◦
Interconnection: CAN0 and CAN1 I/O signals can be connected together for loopback testing
.
•
UART Controller
◦
Quantity: Two UART controllers (UART 0 and UART 1)
.
◦
Functionality: A full-duplex asynchronous receiver and transmitter
.
◦
Configurable: Supports a wide range of programmable baud rates and I/O signal formats, including 6, 7, or 8 data bits, 1, 1.5, or 2 stop bits, and various parity options
.
◦
Buffering: Each path includes a 64-byte FIFO for transmit (TxFIFO) and receive (RxFIFO) data
.
◦
Modes: Features an I/O mode switch for normal, automatic echo, local loopback, and remote loopback configurations
.
◦
Modem Control: Modem control signals (CTS, RTS, DSR, DTR, RI, DCD) are available, exclusively on the EMIO interface
.
◦
Loopback: Has an option to loop UART 0 with UART 1
.
•
I2C Controller
◦
Quantity: Two I2C controllers
.
◦
Modes: Supports master mode (write and read transfers) and slave monitor mode
.
◦
Interface: Uses SCL (Serial Clock) and SDA (Serial Data) signals
.
◦
Initiation: I2C transfers are initiated by the APB host
.
•
Quad-SPI Flash Controller
◦
Modes: Supports serial, dual, and quad modes
.
◦
Access: Software accesses via the AHB interconnect
.
•
Static Memory Controller (SMC)
◦
Support: Supports Parallel NOR/SRAM and NAND Flash memories
.
◦
Interfaces: Uses an AXI interface for memory-mapped access in NOR/SRAM mode and for writing commands in NAND flash mode; an APB bus for control and status registers
.
•
SD/SDIO Controller
◦
Quantity: Two secure digital (SD) ports
.
◦
Devices: Supports both SD and SDIO devices
.
◦
DMA: Features master mode for DMA transfers with a 1 KB FIFO
.
◦
Speeds: Operates at Low-speed (1 KHz to 400 KHz) and Full-speed (1 MHz to 50 MHz)
.
◦
Transfer Types: Supports Single Block Transfer, Multiple Block Transfer, and Infinite Block Transfer
.
•
JTAG and DAP Subsystem
◦
Purpose: Provides debug access via a standard JTAG (IEEE 1149.1) debug interface
.
◦
Components: Implements an ARM Debug Access Port (DAP) within the PS and a JTAG Test Access Port (TAP) controller within the PL
.
◦
Modes: Supports cascaded JTAG chain mode (both TAP and DAP visible) and independent JTAG mode (separate access)
.
◦
Routing: PJTAG signals for ARM DAP can be routed through MIO or EMIO to PL SelectIO pins
.
•
Programmable Logic (PL) Test and Debug (FTM)
◦
Component: The Fabric Trace Monitor (FTM) is a Xilinx-supplied component for PL test and debug, part of the ARM CoreSight architecture
.
◦
Trace Data: Captures 32-bit trace data and a 4-bit trace ID from the PL
.
◦
Buffering: Utilizes FIFO buffering for trace packets to absorb bursts of data from the PL
.
◦
Cross-Triggering: Supports cross-triggering between the PS and PL
.
◦
Trace Output: The Trace Port Interface Unit (TPIU) outputs trace data to the PL or to chip pinouts (via MIO or EMIO)
.

hey provide me the all important information about the usb from the all sources try to be genric that means applicable to any device
And also provide all essential information for the USB driver development information from the host side
Here is a comprehensive overview of USB communication and essential information for USB driver development, specifically from the host side, drawing from the provided sources:
I. USB Communication: Generic Principles
The Universal Serial Bus (USB) protocol was developed to replace a variety of slower, disparate connections with a single, versatile bus type
. It enables hot-pluggability, meaning devices can be connected or disconnected without restarting the system
.
•
Fundamental Operation
◦
Polling Mechanism: USB 2.0 primarily operates on a polling mechanism, where only the host can initiate transactions on the bus. Devices respond to these host requests
.
◦
Directionality: Communication in USB 2.0 is half-duplex, meaning data transmission and reception cannot occur simultaneously
.
▪
IN Data: Information moves from the device to the host
.
▪
OUT Data: Information moves from the host to the device
.
◦
Data Transmission: Data on the USB bus is transmitted with the least significant bit (LSB) first
.
◦
Error Detection: Cyclic Redundancy Checks (CRC) are used to detect errors in transactions, where a checksum is appended to the data packet for integrity verification
.
•
Frames and Microframes
◦
For Low-Speed (1.5 Mbit/s) and Full-Speed (12 Mbit/s) devices, the host controller divides bus time into 1 ms frames
.
◦
For High-Speed devices (480 Mbit/s), each frame is subdivided into 125 µs microframes
. Multiple transactions can occur within each frame or microframe
.
•
USB Endpoints
◦
Definition: An endpoint is a uniquely addressable buffer on a USB device that facilitates information sharing with the host
. Endpoints are hardware components on the device itself, independent of the host operating system
.
◦
Unidirectional: Each endpoint is unidirectional, meaning data flows only in the direction permitted by that specific endpoint (either IN or OUT)
.
◦
Types: The USB specification defines 32 possible endpoints (16 IN and 16 OUT) that can be accessed after initial configuration
.
◦
Control Endpoint (Endpoint 0): Every USB device must provide a special, bidirectional endpoint at address 0, known as the default endpoint or Endpoint 0
. It is used for initial communication, system-level control, and device setup/initial configuration, playing a crucial role in the device enumeration process
.
•
USB Pipes
◦
Definition: A pipe is a software abstraction on the host side, representing a communication channel established between a specific endpoint on the USB device and the host controller
. The other end of the pipe is always the host controller
.
◦
Lifecycle: A pipe for an endpoint is "opened" when the device is configured by selecting a configuration and an interface's alternate setting, at which point it becomes active for I/O operations
. An unconfigured endpoint is simply an "endpoint," while a configured one is a "pipe"
.
•
USB Transfer Types These transfer types are designed to accommodate the diverse functionalities and polling rate requirements of various USB devices
.
◦
Control Transfers:
▪
Purpose: All USB devices must support control transfers
. They are essential for system-level control, initial device configuration, and the device enumeration process
.
▪
Stages: A control transfer consists of three stages:
1.
Setup Stage: The host sends USB requests to the device. The device always acknowledges the setup stage and cannot send a Negative Acknowledgment (NAK)
.
2.
Optional Data Stage: This stage is used if a data payload needs to be transferred between the host and the device
.
3.
Status Stage: This final stage reports on the success or failure of the preceding stages, typically with a zero-length DATA1 packet
.
▪
Bandwidth: Control transfers are guaranteed to have enough reserved bandwidth
. They have 10% reserved bandwidth for Low-Speed and Full-Speed devices, and 20% for High-Speed devices
.
◦
Interrupt Transfers:
▪
Polling, not true interrupts: Despite the name, the host polls the device at predictable intervals (it's not a true interrupt mechanism where the device initiates communication)
.
▪
Reliability: Offer high data reliability for small amounts of data, with error detection and retransmission guarantees
.
▪
Use Cases: Crucial for Human Interface Devices (HID) like keyboards, mice, and game controllers
.
▪
Bandwidth: Guaranteed to have enough reserved bandwidth
.
◦
Bulk Transfers:
▪
Purpose: Used for transferring large amounts of data
.
▪
Reliability vs. Timing: Guaranteed no data loss, but not guaranteed to complete within a specific time
. Large packets may be split across multiple transfers
.
▪
Use Cases: Common for devices like printers, storage drives, and network devices
. The USB Mass Storage Class (UMS/MSC), used by flash drives and external hard drives, primarily utilizes Bulk endpoints for transferring commands, data, and status via a "Bulk-Only Transport" protocol
.
◦
Isochronous Transfers:
▪
Purpose: Designed for continuous, real-time data streams, such as audio and video
. They transfer large amounts of data
.
▪
Error Handling: Detect errors but are error-tolerant and do not support error recovery mechanisms or handshaking
. Occasional data loss is acceptable for these applications
.
▪
Bandwidth: Guaranteed bandwidth, typically 90% for Low-/Full-Speed and 80% for High-Speed devices (shared with interrupt transfers)
. Not available on Low-Speed devices
.
•
USB Packet Structure and Identifiers (PIDs)
◦
Packet Boundaries: New packets are indicated by a sync pattern, and the end of a packet is marked by an End of Packet (EOP)
.
◦
Packet Identifiers (PIDs): These 8-bit fields identify the type of packet, with the first 4 bits indicating type and the last 4 bits being their complement for error checking
.
▪
Token PIDs: Used by the host to direct traffic. Examples include OUT (starts downstream transaction), IN (starts upstream transaction), SOF (Start of Frame)
. SETUP is also a token PID
.
▪
Data PIDs: Indicate data packets, typically DATA0 and DATA1
.
▪
Handshake PIDs: Sent by the receiver to acknowledge or indicate status. Examples include ACK (successful completion), NAK (negative acknowledgment), STALL (error indication), and NYET (not ready to receive, High-Speed only)
.
▪
Special PIDs: Include PRE (preamble for low-speed packets on higher-speed buses) and PING (checks High-Speed device status after NYET)
.
◦
Packet Content: Besides PID, packets can contain an optional 7-bit device address, a 4-bit endpoint address, optional payload data (0 to 1023 bytes), and an optional CRC (5 or 16 bits)
.
II. USB Driver Development: Host Side
Developing a USB driver for the host side involves understanding how the host operating system interacts with USB devices, particularly concerning device discovery, configuration, and data transfer.
•
Linux USB API Model
◦
USB Core: The Linux kernel provides a USB core subsystem that abstracts away much of the complexity of the USB protocol and hardware controllers
. USB drivers interact with this core
.
◦
Driver Binding: USB drivers typically bind to USB interfaces, rather than the entire USB device, as an interface represents a basic functional unit (e.g., a mouse, a keyboard, an audio stream)
. A single USB device can have multiple interfaces
.
•
Device Discovery and Configuration (Enumeration Process) The "magic" of hot-pluggable USB devices is enabled by a three-step process: Dynamic Detection, Enumeration, and Configuration
.
1.
Dynamic Detection: The host controller monitors USB ports for voltage transitions on the D+ and D- lines, which indicate a new device connection and help determine its speed (Low- or Full-Speed)
. For High-Speed devices, the device issues a K-state, and a High-Speed hub responds with a "KJKJKJ" pattern, after which the device removes its pull-up resistor. If this pattern is not returned, the device operates at Full-Speed
.
2.
Enumeration:
▪
Upon detecting the device speed, the host resets the device by pulling D+ and D- lines low
.
▪
The host then communicates with the device via the Control Endpoint (EP0) at the default address 00h
. Only one device can be enumerated at a time using this default address
.
▪
The host sends a GET_DESCRIPTOR command to obtain the device descriptor
. This descriptor provides essential information such as the USB specification version, device class, vendor ID, product ID, and maximum packet size for Endpoint 0 (bMaxPacketSize0). If the descriptor is larger than bMaxPacketSize0, it's sent in smaller chunks
.
▪
After receiving the device descriptor, the host resets the device again and assigns it a new, unique address using a SET_ADDRESS command
. All subsequent communication with that device uses this new address
.
▪
The host then sends another GET_DESCRIPTOR command (using the new address) to read all descriptors from the device (device, configuration, interface, endpoint, and string descriptors)
. This information allows the host to understand the device's capabilities, including its interfaces, power requirements, and supported configurations
.
3.
Configuration:
▪
Once all descriptors are received, the host sends a SET_CONFIGURATION request to select a specific device configuration
.
▪
Finally, the host loads the appropriate device driver (e.g., on Windows, it uses .inf files to match Vendor ID and Product ID)
. The device enters a "configured state" and is ready for use
.
•
USB Descriptors (Detailed) USB descriptors are small information packets acting as an "identity card" or "manual" for the device, telling the host how to communicate with and use it
.
◦
Types of USB Requests: Descriptors are requested using different types of USB requests:
▪
Standard Requests: Defined by the USB specification, mandatory for all devices (e.g., getting device info, setting configurations)
.
▪
Class Requests: Specific to a device class (e.g., printers, storage devices), defined by class specifications
.
▪
Vendor Requests: Defined by the manufacturer for unique product features
.
◦
Key Descriptor Types:
▪
Device Descriptor: The first descriptor requested, providing essential device information like bLength (18 bytes), bDescriptorType (DEVICE 01h), bcdUSB (USB version), bDeviceClass, bDeviceSubClass, bDeviceProtocol (often 00h if class is defined in interface), bMaxPacketSize0, idVendor, idProduct, bcdDevice (device release number), and bNumConfigurations
.
▪
Configuration Descriptor: Describes a specific device configuration, including bLength (9 bytes), bDescriptorType (CONFIGURATION 02h), wTotalLength (total length including subordinate descriptors), bNumInterfaces (number of interfaces in this configuration), bConfigurationValue (value to select this config), bmAttributes (self-powered, remote wakeup), and bMaxPower (max power drawn)
.
▪
Interface Association Descriptor (IAD): Groups multiple interfaces into a single functional unit, introduced to support complex multi-interface devices
.
▪
Interface Descriptor: Defines a collection of endpoints within a USB device, acting as a blueprint for communication
. It provides information like class code (e.g., audio, HID, mass storage), endpoints, protocol, and alternate settings
.
▪
Endpoint Descriptor: Provides essential information for a specific endpoint, including bLength (7 bytes), bDescriptorType (ENDPOINT 05h), bEndpointAddress (endpoint number and direction IN/OUT), and bmAttributes (transfer type: Control, Isochronous, Bulk, Interrupt)
.
▪
String Descriptor: Provides human-readable text strings (optional but recommended) for device name, manufacturer, product, serial number, etc., supporting multiple languages
.
◦
USB Classes: Define capabilities and functionalities, ensuring compatibility
.
▪
Standard Classes: Defined by official USB specifications for common device types (e.g., HID for keyboards/mice, Mass Storage for drives, Audio for speakers/mics, Video for webcams, Printer, Communication Device Class (CDC) for modems/serial ports)
.
▪
Vendor-Specific Classes: Not part of official specs, implemented by vendors for specialized functionalities, often requiring vendor-specific drivers
.
•
Linux USB Request Block (URB) The Linux kernel communicates with USB devices using a USB Request Block (URB), represented by the struct urb structure
. An URB is used to send or receive data to or from a specific USB endpoint on a specific USB device asynchronously
.
◦
URB Lifecycle:
1.
Creation: Allocated dynamically using usb_alloc_urb
. It must not be created statically
.
2.
Assignment & Initialization: Assigned to a specific endpoint on a USB device
. Helper functions like usb_fill_int_urb, usb_fill_bulk_urb, and usb_fill_control_urb are used for initialization, specifying parameters like device, pipe (endpoint and direction), transfer buffer, length, completion handler, and context. Isochronous URBs require manual initialization. The pipe parameter is created using functions like usb_sndctrlpipe, usb_rcvctrlpipe, etc.
.
3.
Submission: Submitted to the USB core using usb_submit_urb. Once submitted successfully, the driver should not access URB fields until the completion handler is called
. The mem_flags parameter is important, often GFP_KERNEL
.
4.
Processing: The USB core submits it to the host controller driver, which performs the USB transfer
.
5.
Completion: The host controller driver notifies the USB device driver when the URB is completed. This triggers the completion handler function (usb_complete_t)
.
•
The completion handler is called exactly once when the URB is finished, regardless of success, error, or cancellation
.
•
The status field within the URB indicates the outcome (0 for success, negative error code for failure)
. Common error values include -ENOENT (stopped by usb_kill_urb), -ECONNRESET (unlinked), -EPROTO (bitstuff error, no response), -EILSEQ (CRC mismatch), -EPIPE (endpoint stalled), -ECOMM (data overrun), -ENOSR (data underrun), -EOVERFLOW (babble error), -EREMOTEIO (short read when not OK), -ENODEV (device gone), -EINVAL (bad parameter), -ESHUTDOWN (severe host controller error or device disconnected)
.
6.
Cancellation: URBs can be canceled by the driver (usb_unlink_urb or usb_kill_urb) or by the USB core if the device is removed
. usb_kill_urb stops the URB lifecycle, typically used on device disconnection. usb_unlink_urb is asynchronous, returning immediately, useful in interrupt contexts
.
◦
Synchronous USB Transfers (without URBs): For simpler, individual transfers, usb_bulk_msg and usb_control_msg functions are available
. These functions create and submit an URB internally, waiting for completion before returning. They cannot be called from interrupt context or with a spinlock held, and cannot be canceled by other functions
.
◦
Helper Functions for Descriptors:
▪
usb_get_descriptor: Retrieves a specified USB descriptor from a device
.
▪
usb_get_string: Retrieves a string descriptor in UTF-16LE format
.
▪
usb_string: A helper function that returns a string already converted to ISO 8859-1 format, which is typically more useful
.
•
Linux USB Driver Structure (struct usb_driver) A USB driver registers itself with the USB subsystem using a struct usb_driver object
.
◦
Key Fields:
▪
owner: Set to THIS_MODULE for reference counting
.
▪
name: Unique name for the driver, appearing in sysfs
.
▪
id_table: A pointer to a struct usb_device_id table, listing the types of USB devices the driver supports
. This table uses fields like idVendor, idProduct, bDeviceClass, bInterfaceClass, etc., to match devices. Macros like USB_DEVICE and USB_INTERFACE_INFO simplify initialization
.
▪
probe: A function pointer called by the USB core when it finds a struct usb_interface that the driver might handle
. The driver initializes the device and returns 0 if it claims the device, or a negative error value otherwise
.
▪
disconnect: A function pointer called when the struct usb_interface is removed or the driver is unloaded
.
◦
Registration/Deregistration: The driver registers using usb_register (or usb_register_driver) during module initialization and usb_deregister_driver when unloading
.
◦
Probe and Disconnect Details:
▪
These functions are called in the context of the USB hub kernel thread, allowing them to sleep
.
▪
In probe, the driver initializes local data structures, detects endpoint addresses and buffer sizes (e.g., using bEndpointAddress and wMaxPacketSize from endpoint descriptors)
.
▪
The driver can store a pointer to its private data structure within the struct usb_interface using usb_set_intfdata and retrieve it later using usb_get_intfdata
. This avoids static arrays and allows for an unlimited number of devices
.
▪
If the USB driver wants to expose a character device interface to user space (not through other subsystems like input or tty), it can call usb_register_dev in probe to allocate a minor number
. The struct usb_class_driver provides details for this registration
.
▪
In disconnect, the driver must clean up all resources associated with the device. If usb_register_dev was called, usb_deregister_dev must be called to release the minor number
. It's crucial to retrieve and then nullify the private data pointer using usb_get_intfdata and usb_set_intfdata to prevent improper access
.
▪
The USB core automatically cancels all URBs in transmission for a device just before disconnect is called
.
•
Sysfs Representation of USB Devices:
◦
The complexity of a USB physical device is reflected in sysfs, where both the struct usb_device and individual struct usb_interface are shown as separate devices
.
◦
The sysfs path for a USB device follows a naming scheme like root_hub-hub_port:config.interface (e.g., 2-1:1.0)
.
◦
Most USB-specific information (like idVendor, idProduct, bMaxPower) is directly available through sysfs files
.
◦
While sysfs stops at the interface level, the usbfs filesystem (mounted at /proc/bus/usb/) provides more detailed information, including alternate configurations and endpoint details, and allows user-space programs to directly communicate with USB devices
.
III. Zynq-7000 SoC USB Controller: Host Mode Specifics
The Zynq-7000 SoC includes a sophisticated USB controller that can operate in both Host and Device modes, making it versatile for embedded applications
.
•
Controller Architecture:
◦
The USB controller is a USB 2.0 High-Speed On-The-Go (OTG) dual-role controller, supporting Host, Device, or OTG operations using the same hardware
.
◦
It features a built-in DMA engine and a Protocol Engine
.
▪
The DMA engine moves USB transaction data between Rx/Tx FIFOs and system memory (DDR, OCM, or PL-mapped memory)
.
▪
The Protocol Engine interprets USB packets, generates responses, and performs error checking
.
◦
It employs Dual-Port RAM to implement Rx/Tx FIFOs and store context information (like Queue Heads and Transfer Descriptors), decoupling system memory transfers from real-time USB requirements
.
◦
It is compatible with the Intel EHCI (Enhanced Host Controller Interface) software programming model for Host mode
.
•
Transfer Descriptors (Host Mode): The host controller is a schedule-driven environment for data transfers. It manages transfers using linked-list descriptors in system memory
.
◦
Periodic Schedule (Isochronous/Interrupt):
▪
Isochronous Transfer Descriptor (iTD): Used for High-Speed isochronous endpoints
.
▪
Split Transaction Isochronous Transfer Descriptor (siTD): Manages Full-Speed isochronous transfers via split transactions to a USB 2.0 Hub Transaction Translator
.
▪
Periodic Frame Span Traversal Node (FSTN): Used for Full-/Low-Speed devices downstream of a High-Speed hub that span frame boundaries
.
▪
The periodic schedule uses a Periodic Frame List, a 4 KB page-aligned array of pointers to descriptors, whose length is programmable (8 to 1024 elements)
.
◦
Asynchronous Schedule (Control/Bulk):
▪
Queue Head (QH): Manages interrupt, control, and bulk data streams, forming a circular list
.
▪
Queue Element Transfer Descriptor (qTD): Used with QHs for one or more USB transactions, capable of transferring up to 20,480 bytes
.
▪
The asynchronous schedule executes after the periodic schedule and implements a round-robin service for QHs
.
•
Embedded Transaction Translator (TT):
◦
The Zynq-7000 USB host controller has an embedded Transaction Translator (TT) function implemented within its DMA and protocol engines
.
◦
This allows direct connection to Low-Speed and Full-Speed devices without needing an external USB 2.0 hub
.
◦
The TT emulates the behavior of a traditional hub-based TT, simplifying the Host Controller Driver (HCD) by minimizing changes needed to handle FS/LS devices directly connected
.
•
Physical Interface and I/O:
◦
The controller uses the ULPI (UTMI+ Low Pin Interface) protocol to connect to an external ULPI PHY via MIO (Multiplexed I/O) pins
. ULPI provides an 8-bit parallel SDR data path
.
◦
MIO and EMIO (Extended MIO): I/O signals for USB can be routed through MIO pins directly or through the EMIO interface to the Programmable Logic (PL) pins
. For example, port indicator and power control signals are typically routed via EMIO to PL SelectIO pins
.
◦
Clocks: The ULPI interface and Protocol Engine are clocked by a 60 MHz input from the external PHY
. The AHB interface is clocked by the CPU_1x clock
.
◦
Resets: The controller supports various resets, including a full controller reset (from PS reset system), a partial controller reset (usb.USBCMD [RST]), and an external ULPI PHY reset (which typically requires a PS or PL GPIO signal)
.
•
Software Access and Registers:
◦
Controller registers are memory-mapped
. Control and status registers are accessed via the APB (Advanced Peripheral Bus) bus, while the DMA engine uses the AHB (Advanced High-performance Bus) master interface for data transfers
.
◦
The Zynq-7000 SoC provides device drivers in source format for bare-metal/standalone and Linux environments
.
